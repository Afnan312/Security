# -*- coding: utf-8 -*-
"""BitVectorDemo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NoLVEBqkvrHwoYoEuxX0BeJvaJ5MtVrA
"""
import BitVector as BitVector
import copy
import string
import random
import numpy as np
import datetime

"""Tables"""

from BitVector import *

Sbox = (
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
)

InvSbox = (
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
)

Mixer = [
    [BitVector(hexstring="02"), BitVector(hexstring="03"), BitVector(hexstring="01"), BitVector(hexstring="01")],
    [BitVector(hexstring="01"), BitVector(hexstring="02"), BitVector(hexstring="03"), BitVector(hexstring="01")],
    [BitVector(hexstring="01"), BitVector(hexstring="01"), BitVector(hexstring="02"), BitVector(hexstring="03")],
    [BitVector(hexstring="03"), BitVector(hexstring="01"), BitVector(hexstring="01"), BitVector(hexstring="02")]
]

InvMixer = [
    [BitVector(hexstring="0E"), BitVector(hexstring="0B"), BitVector(hexstring="0D"), BitVector(hexstring="09")],
    [BitVector(hexstring="09"), BitVector(hexstring="0E"), BitVector(hexstring="0B"), BitVector(hexstring="0D")],
    [BitVector(hexstring="0D"), BitVector(hexstring="09"), BitVector(hexstring="0E"), BitVector(hexstring="0B")],
    [BitVector(hexstring="0B"), BitVector(hexstring="0D"), BitVector(hexstring="09"), BitVector(hexstring="0E")]
]


AES_modulus = BitVector(bitstring='100011011')


all_keys = []


def rotate_left(row, n=1):
    return row[n:] + row[:n]


def word_xor(w1, w2):
    w = [0 for _ in range(4)]
    for k in range(4):
        first = BitVector(hexstring=w1[k])
        first = first.intValue()
        second = BitVector(hexstring=w2[k])
        second = second.intValue()
        z = first ^ second
        w[k] = hex(z)[2:].rjust(2, '0')
    return w


def key_expansion(given_hex_key):
    round_constants = [["01", "00", "00", "00"]]
    rc = 1
    for k in range(10):
        rc *= 2
        if rc > 0x80:
            rc ^= 0x11b
        round_constants.append([hex(rc)[2:], "00", "00", "00"])

    separated = given_hex_key.split(",")
    words = [[0 for _ in range(4)] for _ in range(4)]
    j = 0
    for k in separated:
        words[int(j / 4)][j % 4] = k
        j += 1
    all_keys.append(copy.deepcopy(words))
    # print(all_keys)

    for r in range(10):
        g_funct = words[3]
        g_funct = rotate_left(g_funct)
        k = 0
        rounding = round_constants[r]
        # print(rounding)
        for el in g_funct:
            element = BitVector(hexstring=el)
            val = element.intValue()
            s_val = Sbox[val]  # get the sbox value
            s_val = BitVector(intVal=s_val, size=8)
            x = int(s_val.get_bitvector_in_hex(), 16)
            t = BitVector(hexstring=rounding[k])
            y = t.intValue()
            z = x ^ y
            g_funct[k] = hex(z)[2:].rjust(2, '0')
            k += 1
        words[0] = word_xor(words[0], g_funct)
        words[1] = word_xor(words[1], words[0])
        words[2] = word_xor(words[2], words[1])
        words[3] = word_xor(words[3], words[2])
        new_word = copy.deepcopy(words)
        all_keys.append(new_word)
    # for row in all_keys:
    #     print(row)


def arr_xor(arr1, arr2):
    a = [[0 for _ in range(4)] for _ in range(4)]
    for k in range(4):
        for j in range(4):
            x = int(arr1[k][j], 16) ^ int(arr2[k][j], 16)
            a[k][j] = hex(x)[2:].rjust(2, '0')
    return a


def mix_col(mat):
    a = [[0 for _ in range(4)] for _ in range(4)]
    for k in range(4):
        for j in range(4):
            x = 0
            for m in range(4):
                mx = Mixer[k][m]
                val = mat[m][j]
                bv = BitVector(hexstring=val)
                br = mx.gf_multiply_modular(bv, AES_modulus, 8)
                br = br.intValue()
                x = x ^ br
            a[k][j] = hex(x)[2:].rjust(2, '0')
    return a


def rev_mix_col(mat):
    a = [[0 for _ in range(4)] for _ in range(4)]
    for k in range(4):
        for j in range(4):
            x = 0
            for m in range(4):
                mx = InvMixer[k][m]
                val = mat[m][j]
                bv = BitVector(hexstring=val)
                br = mx.gf_multiply_modular(bv, AES_modulus, 8)
                br = br.intValue()
                x = x ^ br
            a[k][j] = hex(x)[2:].rjust(2, '0')
    return a


def encrypt(plain_blocks, iv_given):
    crypt = []
    iv_hex = iv_given.encode("utf-8").hex(sep=",").rjust(2, '0')
    separate = iv_hex.split(",")
    iv_mat = [[0 for _ in range(4)] for _ in range(4)]
    j = 0
    for k in separate:
        iv_mat[int(j / 4)][j % 4] = k
        j += 1
    iv_mat = np.transpose(iv_mat)
    for block in plain_blocks:
        hex_val = block.encode("utf-8").hex(sep=",").rjust(2, '0')
        separated = hex_val.split(",")
        words = [[0 for _ in range(4)] for _ in range(4)]
        j = 0
        for k in separated:
            words[int(j / 4)][j % 4] = k
            j += 1
        words = np.transpose(words)
        words = arr_xor(words, iv_mat)
        key0 = all_keys[0]
        key0 = np.transpose(key0)
        s_mat = arr_xor(words, key0)
        for a_round in range(1, 10):
            for k in range(4):
                li = 0
                for el in s_mat[k]:
                    element = BitVector(hexstring=el)
                    val = element.intValue()
                    s_val = Sbox[val]  # get the sbox value
                    s_val = BitVector(intVal=s_val, size=8)
                    s_mat[k][li] = s_val.get_bitvector_in_hex().rjust(2, '0')
                    li += 1
                s_mat[k] = rotate_left(s_mat[k], k)
            s_mat = mix_col(s_mat)
            # print(s_mat)
            a_key = all_keys[a_round]
            a_key = np.transpose(a_key)
            # print(a_key)
            # print(s_mat)
            s_mat = arr_xor(s_mat, a_key)
        for k in range(4):
            li = 0
            for el in s_mat[k]:
                element = BitVector(hexstring=el)
                val = element.intValue()
                s_val = Sbox[val]  # get the sbox value
                s_val = BitVector(intVal=s_val, size=8)
                s_mat[k][li] = s_val.get_bitvector_in_hex().rjust(2, '0')
                li += 1
            s_mat[k] = rotate_left(s_mat[k], k)
        a_key = all_keys[10]
        a_key = np.transpose(a_key)
        s_mat = arr_xor(s_mat, a_key)
        iv_mat = copy.deepcopy(s_mat)
        crypt.append(copy.deepcopy(s_mat))
    return crypt


def decrypt(crypt, iv_given):
    decrypting = []
    iv_hex = iv_given.encode("utf-8").hex(sep=",").rjust(2, '0')
    separate = iv_hex.split(",")
    iv_mat = [[0 for _ in range(4)] for _ in range(4)]
    j = 0
    for k in separate:
        iv_mat[int(j / 4)][j % 4] = k
        j += 1
    iv_mat = np.transpose(iv_mat)
    for s_mat in crypt:
        next_mat = copy.deepcopy(s_mat)
        a_key = all_keys[10]
        a_key = np.transpose(a_key)
        s_mat = arr_xor(s_mat, a_key)
        for k in range(4):
            li = 0
            for el in s_mat[k]:
                element = BitVector(hexstring=el)
                val = element.intValue()
                s_val = InvSbox[val]  # get the sbox value
                s_val = BitVector(intVal=s_val, size=8)
                s_mat[k][li] = s_val.get_bitvector_in_hex().rjust(2, '0')
                li += 1
            if k != 0:
                s_mat[k] = rotate_left(s_mat[k], 4 - k)
        for a_round in reversed(range(1, 10)):
            a_key = all_keys[a_round]
            a_key = np.transpose(a_key)
            # print(a_key)
            # print(s_mat)
            s_mat = arr_xor(s_mat, a_key)
            s_mat = rev_mix_col(s_mat)
            # print(s_mat)
            for k in range(4):
                li = 0
                for el in s_mat[k]:
                    element = BitVector(hexstring=el)
                    val = element.intValue()
                    s_val = InvSbox[val]  # get the sbox value
                    s_val = BitVector(intVal=s_val, size=8)
                    s_mat[k][li] = s_val.get_bitvector_in_hex().rjust(2, '0')
                    li += 1
                if k != 0:
                    s_mat[k] = rotate_left(s_mat[k], 4 - k)
        key0 = all_keys[0]
        key0 = np.transpose(key0)
        s_mat = arr_xor(s_mat, key0)
        s_mat = arr_xor(s_mat, iv_mat)
        iv_mat = next_mat
        decrypting.append(copy.deepcopy(s_mat))
    return decrypting


def get_iv():
    iv_ = ''.join(random.choices(string.ascii_letters, k=16))
    return iv_


# test_key = "Thats my Kung Fu"
# test_text = "Forty five twenty nine the=rhoh083"
# hex_key = test_key.encode("utf-8").hex(sep=",").rjust(2, '0')
# text_blocks = []
# for i in range(0, len(test_text), 16):
#     text_blocks.append(test_text[i:i + 16])
# key_expansion(hex_key)
# iv = ''.join(random.choices(string.ascii_letters, k=16))
# print(iv)
# encrypted = encrypt(text_blocks, iv)
# decrypted = decrypt(encrypted, iv)
# ascii_decrypt = ''
# for block in decrypted:
#     block = np.transpose(block)
#     for row in block:
#         for char in row:
#             if char == '00':
#                 continue
#             ascii_decrypt += (chr(int(char, 16)))
# print(ascii_decrypt)


print("Key:")
key_text = input("In ASCII:")
if len(key_text) < 16:
    print("Input length is less than 16. Padding the input with 0.")
    key_text = key_text.ljust(16, '0')
elif len(key_text) > 16:
    print("Input length is more than 16. Input is made 16 bits.")
    key_text = key_text[0:16]
hex_key = key_text.encode("utf-8").hex(sep=",")
print("In HEX")
print(hex_key)

print("Plaintext:")
plaintext = input("In ASCII:")
if len(plaintext) % 16 != 0:
    padding = 16 - len(plaintext) % 16
    plaintext = plaintext + " " * padding

text_blocks = []
for i in range(0, len(plaintext), 16):
    text_blocks.append(plaintext[i:i + 16])

hex_text = plaintext.encode("utf-8").hex(sep=",")
print("In HEX")
print(hex_text)
print("")
iv = get_iv()

start_key = datetime.datetime.now()
key_expansion(hex_key)
end_key = datetime.datetime.now()
execution_time_key = (end_key - start_key).total_seconds() * 1000

start_e = datetime.datetime.now()
encrypted = encrypt(text_blocks, iv)
end_e = datetime.datetime.now()
execution_time_e = (end_e - start_e).total_seconds() * 1000

encrypts = ''
encrypts_ascii = ''
for e_block in encrypted:
    e_block = np.transpose(e_block)
    for row in e_block:
        for char in row:
            encrypts += char
            encrypts += " "
            encrypts_ascii += (chr(int(char, 16)))
print("Ciphered Text:")
print("In HEX:")
print(encrypts)
print("In ASCII:")
print(encrypts_ascii)
print("")

start_d = datetime.datetime.now()
decrypted = decrypt(encrypted, iv)
end_d = datetime.datetime.now()
execution_time_d = (end_d - start_d).total_seconds() * 1000
decrypts = ''
ascii_decrypt = ''
for e_block in decrypted:
    e_block = np.transpose(e_block)
    for row in e_block:
        for char in row:
            decrypts += char
            decrypts += " "
            if char == '00':
                continue
            ascii_decrypt += (chr(int(char, 16)))
print("Deciphered Text:")
print("In HEX:")
print(decrypts)
print("In ASCII:")
print(ascii_decrypt)
print("")

print("Execution Time Details:")
print(f'Key Schedule Time: {execution_time_key} ms')
print(f'Encryption Time: {execution_time_e} ms')
print(f'Decryption Time: {execution_time_d} ms')
